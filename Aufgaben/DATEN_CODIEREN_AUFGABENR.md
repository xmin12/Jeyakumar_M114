# Lösungen zu DATEN_CODIEREN_AUFGABEN

## 1. Tabelle mit Dezimal-, Hexadezimal- und Binärzahlen



## 2. Dezimalzahl 911 in Binär

**Dezimal:** 911  
**Binär:** `1110001111`

## 3. Binärzahl `1011'0110` in Dezimal

**Binär:** `1011'0110`  
**Dezimal:** 182

## 4. Binärzahl `1110'0010'1010'0101` in Hexadezimal

**Binär:** `1110'0010'1010'0101`  
**Hexadezimal:** `E2A5`

Beim Ausrechnen: 0 + 0 = 0, 0 + 1 = 1, 1 + 0 = 1, und 1 + 1 = 10.

## 5. Addition der binären Zahlen `1101'1001` und `0111'0101`

**Ergebnis in 8 Bit:** `01001110`

## 6. Bedeutung der binären Werte

### a. Dezimal: `192.168.76.211`, Hexadezimal: `C0.A8.4C.D3`

### b. Dezimal: `190.131.133.213.228.254`, Hexadezimal: `BE.83.85.D5.E4.FE`

## 8. Codebreite des Binärcodes für Kabinenzählung

2^7 = 7 Bits  
Die nächste Zahl, die nach 107 kommt, wäre 128.

## 11. Umwandlung und Operationen mit vorzeichenbehafteten und vorzeichenlosen Ganzzahlen

### a. Kleinster und größter Binärwert bzw. Dezimaläquivalent im Falle von unsigned bzw. vorzeichenlos. In Dezimal:

0 - 255

### b. Kleinster und größter Binärwert bzw. Dezimaläquivalent (signed) In Dezimal:

-128 - 127

### c. Dezimalzahl +83 in vorzeichenbehafteten Binärwert (signed). In Binärwert:

`0101 0011`

### d. Dezimalzahl -83 in vorzeichenbehafteten Binärwert (signed mit 2er-Komplement). In Binärwert:

`1010 1101`

Man invertiert das Positive ins Negative: `0101 0011` -> `1010 1100`  
Negative Werte haben immer eine 1 als erste Binärzahl: `XXXX XXX1` -> `1010 1101`

### e. Addition der beiden erhaltenen Binärwerte:

`100000000` und in 8 Bits: `0000 0000`

### f. Dezimalzahl 0 in einen vorzeichenbehafteten Binärwert umwandeln (signed):

**Binärwert:** `00000000`  
Ja, in 8 Bit ist es dasselbe.

### g. Warum können sie bei der gegebenen Datenbusbreite von 1 Byte die Dezimalzahl +150 nicht in einen vorzeichenbehafteten Binärwert umwandeln?

Die Zahl +150 überschreitet den maximal möglichen positiven Wert (+127) in einem 8-Bit vorzeichenbehafteten System. Deshalb kann +150 nicht korrekt in einem Byte dargestellt werden, wenn es als vorzeichenbehaftete Ganzzahl interpretiert wird.

## 12. Fliesskommazahlen

Manchmal werden Bruch- oder Dezimalwerte als ganze Zahlen dargestellt. Für solche Fälle sind Fliesskommazahlen die richtige Wahl.

Normalerweise würde ein int von 0.3333333 so aussehen: 0, aber dank float sieht es in seiner aktuellen Form aus.

## Aufgaben zu alphanumerischen Codes

### Welche der Dateien ist nun ASCII-codiert, welche UTF-8 und welche UTF-16 BE-BOM?

- **Textsample1:** ASCII
- **Textsample2:** UTF-8
- **Textsample3:** UTF-16 BE-BOM

### Alle drei Dateien enthalten denselben Text. Aus wie vielen Zeichen besteht dieser?

68 Zeichen

### Dateigrößen?

- **Textsample1:** 68 Bytes
- **Textsample2:** 71 Bytes
- **Textsample3:** 138 Bytes

### ASCII- und die UTF-8-Datei

- Umlaut: `ä`
- Eurozeichen: `€`

### Big-Endian (BE), Little-Endian (LE) in UTF-16

- **Big-Endian:** Byte-Reihenfolge wie `hh:mm:ss`
- **Little-Endian:** Byte-Reihenfolge wie `dd:mm:yyyy`

### Änderungen?

Durch das Abwechseln des Encodings von ASCII zu UTF werden die Zeichen des Textes angepasst.
```
